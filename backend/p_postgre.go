package backend

// imports

import (
	"database/sql"
	"encoding/binary"
	"fmt"
	"io"

	"os"
	"strconv"
	"strings"
	"time"

	"github.com/jhillyerd/enmime"
	"github.com/joho/godotenv"
	"github.com/lib/pq"
	"github.com/phires/go-guerrilla/backends"
	"github.com/phires/go-guerrilla/log"
	"github.com/phires/go-guerrilla/mail"
)

// ----------------------------------------------------------------------------------
// Processor Name: PSQLProcessor
// ----------------------------------------------------------------------------------
// Description   : saves the email data, headers and body to PSQL database.
// ----------------------------------------------------------------------------------
// Config Options:
//
//    : mail_table string - name of table for storing emails
//    : primary_mail_host string - primary host name
// --------------:-------------------------------------------------------------------
// Input         :
//
//    : e.Header - generated by Header processor
//    : e.RcptTo
//    : e.Subject - generated by by ParseHeader processor
//    : e.RemoteIP - generated by by ParseHeader processor
//    : e.Values["enmime_envelope"] - generated by MimeParser processor
// ----------------------------------------------------------------------------------
// Output        : None
// ----------------------------------------------------------------------------------

type PSQL struct {
	config *psqlConfig // config entity
	cache  *sql.Stmt   // a struct to store a prepared statement and execute it when needed
	logger log.Logger  // logger
}

// vars to load from the backend configuration
type psqlConfig struct {
	Table       string `json:"mail_table"`
	PrimaryHost string `json:"primary_mail_host"`
}

// processor initializer function
type ProcessorIntiitializer interface {
	Initialize(backendConfig backends.BackendConfig) error
}

// processor shutdown function
type ProcessorShutdowner interface {
	Shutdown() error
}

// The PSQLProcessor decorator [save emails to database]
var PSQLProcessor = func() backends.Decorator {
	var (
		config *psqlConfig   // config entity
		db     *sql.DB       // database instance
		vals   []interface{} // email data to write to the database
	)

	p_psql := &PSQL{
		logger: backends.Log(),
	}

	backends.Svc.AddInitializer(backends.InitializeWith(func(backendConfig backends.BackendConfig) error {
		// fetch the backend configuration data
		configType := backends.BaseConfig(&psqlConfig{})
		bcfg, err := backends.Svc.ExtractConfig(backendConfig, configType)
		if err != nil {
			return err
		}
		// save backend configuration
		config = bcfg.(*psqlConfig)
		p_psql.config = config

		// load database connection parameters from .env file
		err = godotenv.Load()
		if err != nil {
			p_psql.logger.Warn("Failed to load ENV variables") // ignore the message if the variables are already set in the environment
		}

		// create the database connection and save it
		db, err = p_psql.connectToDb(os.Getenv("DB_HOST"), os.Getenv("DB_NAME"), os.Getenv("DB_USER"), os.Getenv("DB_SECRET"), os.Getenv("DB_SSLMODE"))
		if err != nil {
			return err
		}
		return nil
	}))

	backends.Svc.AddShutdowner(backends.ShutdownWith(func() error {
		// close the database connection if it's open
		if db != nil {
			return db.Close()
		}
		return nil
	}))

	// future development note: envelope Header type is map[string][]string (aka key is string, vlaue is a string slice),
	// so when extracting header values like Message-Id, don't forget to use [0] to get the string value.

	return func(p backends.Processor) backends.Processor {
		return backends.ProcessWith(
			func(e *mail.Envelope, task backends.SelectTask) (backends.Result, error) {
				if task == backends.TaskSaveMail {
					// get message id from header, if doesn't exist then generate one
					var message_id string
					message_id_header, ok := e.Header["Message-Id"]
					if ok {
						message_id = message_id_header[0]
					} else {
						message_id = p_psql.generateMessageID(config.PrimaryHost)
					}

					from := p_psql.getAddressesFromHeader(e, "From")
					to := p_psql.getAddressesFromHeader(e, "To")
					reply_to := p_psql.getAddressesFromHeader(e, "Reply-To")
					sender := p_psql.getAddressesFromHeader(e, "Sender")
					recipients := p_psql.getRecipients(e)
					return_path := p_psql.getAddressFromHeader(e, "Return-Path")

					subject := e.Subject
					var body, content_type string
					env_mime, ok := e.Values["envelope_mime"].(*enmime.Envelope)
					if ok {
						p_psql.logger.Debug("Using MIME")
						content_type = env_mime.Root.ContentType
						if strings.Contains(content_type, "plain") {
							body = env_mime.Text
						} else if strings.Contains(content_type, "html") {
							body = env_mime.HTML
						}
					} else {
						p_psql.logger.Debug("Default")
						// use defaults from guerilla envelope
						if value, ok := e.Header["Content-Type"]; ok {
							content_type = value[0]
						}
						// convert the email message into a string
						body = p_psql.getMessageStr(e)
					}

					p_psql.logger.Debug(body)
					p_psql.logger.Debug(content_type)
					ip_addr := e.RemoteIP

					vals = []interface{}{} // clean slate
					// order: "message_id", "from", "to", "reply_to", "sender", "subject", "body", "content_type", "recipient", "ip_addr", "return_path"
					vals = append(vals,
						message_id,
						pq.Array(from),
						pq.Array(to),
						pq.Array(reply_to),
						pq.Array(sender),
						subject,
						body,
						content_type,
						pq.Array(recipients),
						ip_addr,
						return_path,
					)
					// fetch users to create inbox records for
					db_recipients, err := p_psql.getValidRecipients(db, recipients)
					// throw error if the message is not addressed to any users
					if err != nil {
						return backends.NewResult("403 Error: invalid recipient"), err
					}
					// save the email to the emails table
					stmt := p_psql.prepareInsertQuery(db)
					err = p_psql.executeQuery(stmt, &vals)
					if err != nil {
						return backends.NewResult("554 Error: could not save email"), err
					}
					// create inbox entry for every user present in the email recipient list
					for _, v := range db_recipients {
						p_psql.insertInboxEntry(db, v, message_id)
					}
				}
				return p.Process(e, task)
			},
		)
	}
}

// Creates a connection to the database with provided paramaters and returns it as a pointer
func (p_psql *PSQL) connectToDb(host string, name string, user string, secret string, sslmode string) (*sql.DB, error) {
	// define connection string
	connStr := fmt.Sprintf("host=%s dbname=%s user=%s password=%s sslmode=%s", host, name, user, secret, sslmode)
	// connect to db
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		return nil, err
	}
	p_psql.logger.Info("Connected to database.")
	return db, err
}

// Prepares a query for writing an email to database and saves it to `p_psql` STMT cache
func (p_psql *PSQL) prepareInsertQuery(db *sql.DB) *sql.Stmt {
	insertQuery := `INSERT INTO %s("message_id", "from", "to", "reply_to", "sender", "subject", "body", "content_type", "recipient", "ip_addr", "return_path") 
	VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`
	// add query to stmt
	cache, err := db.Prepare(fmt.Sprintf(insertQuery, p_psql.config.Table))
	if err != nil {
		p_psql.logger.Fatal(err)
	}
	p_psql.cache = cache
	return cache
}

// Executes a prepared database query with values `vals`
func (p_psql *PSQL) executeQuery(cache *sql.Stmt, vals *[]interface{}) error {
	p_psql.logger.Debug("Executing query with values %v", vals)
	_, err := cache.Exec(*vals...)
	if err != nil {
		p_psql.logger.Warn("Failed to write data to the database: %s", err)
	}
	return err
}

func (p_psql *PSQL) getAddressFromHeader(e *mail.Envelope, headerKey string) string {
	value, ok := e.Header[headerKey]
	if ok {
		// so, why this? e.Header is set by ParseHeaders(): e.Header, err = headerReader.ReadMIMEHeader()
		// type MIMEHeader map[string][]string from net/textproto
		// i can just fetch the data directly from the e.Header, but it hasn't been validated in any way
		// NewAddress checks the validity of the email address
		// it also kinda works for message-id since its format is <unique.id@domain.com>
		// and func (a *Address) String() string does the heavy lifting of finding whatever field has value and converting it to string
		// Alternatively, I can just make my own regex format checkers without extra overhead and objects
		// TODO: consider writing validators instead of using Address, and add length checks there too
		addr, err := mail.NewAddress(value[0])
		if err != nil {
			return ""
		}
		return addr.String()
	}
	return ""
}

// Verify the email addresses listed in the header `headerKey` are valid.
func (p_psql *PSQL) getAddressesFromHeader(e *mail.Envelope, headerKey string) []string {
	values, ok := e.Header[headerKey]
	if ok {
		var addresses []string
		for _, value := range values {
			addr, err := mail.NewAddress(value)
			if err != nil {
				continue
			}
			addresses = append(addresses, addr.String())
		}
		return addresses
	}
	return nil
}

// Fetches data from RcptTo header and returns is as a slice of strings
func (p_psql *PSQL) getRecipients(e *mail.Envelope) []string {
	var recipients []string
	for _, rcpt := range e.RcptTo {
		recipients = append(recipients, rcpt.String())
	}
	return recipients
}

// Converts the email message into a string
func (p_psql *PSQL) getMessageStr(e *mail.Envelope) string {
	bodyReader := e.NewReader()
	body, err := io.ReadAll(bodyReader)
	if err != nil {
		p_psql.logger.Warn("Failed to read email message.")
		return ""
	}
	return string(body)
}

// Returns a slice of recipients that have user entries  in the database associated with them
func (p_psql *PSQL) getValidRecipients(db *sql.DB, recipients []string) ([]string, error) {
	// get list of recipients
	// get list of inboxes from db
	rows, err := db.Query(`SELECT email_address FROM users;`)
	if err != nil {
		p_psql.logger.Warnln("Failed to fetch inboxes from database: %s", err)
	}
	var inboxes []string
	for rows.Next() {
		var email string
		err := rows.Scan(&email)
		if err != nil {
			p_psql.logger.Fatalln(err)
		}
		inboxes = append(inboxes, email)
	}
	// Get recipients that are present in the users table
	// borrowed from https://github.com/juliangruber/go-intersect/blob/master/intersect.go
	set := make([]string, 0)
	hash := make(map[string]struct{})
	for _, v := range recipients {
		hash[v] = struct{}{}
	}
	for _, v := range inboxes {
		if _, ok := hash[v]; ok {
			set = append(set, v)
		}
	}
	if len(set) == 0 {
		return nil, DatabaseError("No valid email recipients found.")
	}
	return set, nil
}

// Creates a record in `inboxes` table linking email message to the recipient in `users` table
func (p_psql *PSQL) insertInboxEntry(db *sql.DB, email string, message_id string) {
	query := `INSERT INTO inboxes (user_id, mail_id) VALUES ($1, $2)`
	_, err := db.Exec(query, email, message_id)
	if err != nil {
		p_psql.logger.Warnf("Failed to create inbox entry! message_id %s for email %s", message_id, email)
	}
}

// Generates an RFC 2822-compliant Message-Id
// Borrowed from: https://github.com/emersion/go-message/blob/v0.18.1/mail/header.go#L338
func (p_psql *PSQL) generateMessageID(hostname string) string {
	now := uint64(time.Now().UnixNano())
	nonceByte := make([]byte, 8)
	nonce := binary.BigEndian.Uint64(nonceByte)
	message_id := fmt.Sprintf("%s.%s@%s", base36(now), base36(nonce), hostname)
	return message_id
}

func base36(input uint64) string {
	return strings.ToUpper(strconv.FormatUint(input, 36))
}
